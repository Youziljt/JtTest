package com.example.engineeringmode.others.concurrent;

/**
 * @anthor ljt
 * Date: 2/1/21
 * Time: 5:13 PM
 * Description: 并发处理
 *
 * 并发是两个队列交替使用一台咖啡机，
 * 并行是两个队列同时使用两台咖啡机，
 * 如果串行，一个队列使用一台咖啡机，
 *
 */
public class ConCurrent {

    /**
     * 1， 获取单例对象需要保证线程安全，其中方法也要保证线程安全。
     *
     * 2，创建线程或 线程池时请指定有意义线程名称
     *
     * 3，线程池必须通过线程池提供，不允许在应用中自行显示创建线程
     *
     * 4，线程池不允许使用Executors去创建， 而是通过 ThreadPoolExecutor 方式
     *
     * 5，SimpleDateFormat 是线程不安全的类，一般不要定义为static变量，如果定义为static，必须加锁，或者使用DateUtils工具类。
     *
     * 6，高并发时，同步调用应该去考量锁的性能损耗，能用无锁数据结构，就不要用锁，能锁区块，就不要锁整个方法，能用对象锁，就不要类锁
     *
     * 7，对多个资源，数据库表，对象同时加锁时，需要保持一致的加锁顺序，否则可能造成死锁。
     *
     * 8，并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存层加锁，要么在数据库层使用乐观锁，使用version作为更新依据。
     * 说明： 如果每次访问冲突概率小于20%，推荐使用乐观锁， 否则使用悲观锁，乐观锁的重试次数不得小于3次。
     *
     * 9，多线程并行处理定时任务时，Timer 运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其他任务便会自动终止执行，使用ScheduledExecutorService则没有这个问题。
     *
     * 10，使用CountDownLatch进行异步转同步操作，每个线程退出前必须调用countDown方法，线程执行代码注意catch异常，确保countDown方法被执行到，避免主线程无法执行至await方法，直到超时才返回结果。
     * 说明：注意，子线程抛出异常堆栈，不能在主线程try-catch到。
     *
     * 11，避免Random实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降。
     * 说明：Random实例包括java.util.Random 的实例或者 Math.random()的方式。
     * 正例：在JDK7之后，可以直接使用API ThreadLocalRandom，而在 JDK7之前，需要编码保证每个线程持有一个实例。
     *
     * 12，在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优化问题隐患(可参考 The "Double-Checked Locking is Broken" Declaration)，推荐解决方案中较为简单一种（适用于JDK5及以上版本），将目标属性声明为 volatile型。
     *
     * 13，volatile解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。如果是count++操作，使用如下类实现：
     *
     * 14， HashMap在容量不够进行resize时由于高并发可能出现死链，导致CPU飙升，在开发过程中可以使用其它数据结构或加锁来规避此风险。
     *
     * 15，ThreadLocal无法解决共享对象的更新问题，ThreadLocal对象建议使用static修饰。这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个
     *
     */

}
